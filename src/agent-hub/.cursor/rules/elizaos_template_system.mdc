# ElizaOS Template System: Complete Development Guide

## Template System Overview

The ElizaOS Template System is a comprehensive framework for generating AI agent responses, managing character behavior, and handling various interactions. It uses Handlebars.js with enhanced security features and XML-based response formats.

## 1. Core Templates Location and Types

### Main Template File
All core templates are defined in [prompts.ts](mdc:packages/core/src/prompts.ts:1-163):

#### 1.1 shouldRespondTemplate
Controls whether the agent should respond, ignore, or stop a conversation:
```typescript
export const shouldRespondTemplate = `<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>

<providers>
{{providers}}
</providers>

<instructions>Decide if {{agentName}} should respond to or interact with the conversation.
If the message is directed at or relevant to {{agentName}}, respond with RESPOND action.
If a user asks {{agentName}} to be quiet, respond with STOP action.
If {{agentName}} should ignore the message, respond with IGNORE action.</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <name>{{agentName}}</name>
  <reasoning>Your reasoning here</reasoning>
  <action>RESPOND | IGNORE | STOP</action>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
```

**Response Format:**
- `<name>`: Agent name
- `<reasoning>`: Reasoning for the decision
- `<action>`: Single action (RESPOND | IGNORE | STOP)

#### 1.2 messageHandlerTemplate
The main template for generating dialog and actions:
```typescript
export const messageHandlerTemplate = `<task>Generate dialog and actions for the character {{agentName}}.</task>

<providers>
{{providers}}
</providers>

These are the available valid actions:
<actionNames>
{{actionNames}}
</actionNames>

<instructions>
Write a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.

IMPORTANT ACTION ORDERING RULES:
- Actions are executed in the ORDER you list them - the order MATTERS!
- REPLY should come FIRST to acknowledge the user's request before executing other actions
- Common patterns:
  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)
  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)
  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)
- REPLY is used to acknowledge and inform the user about what you're going to do
- Follow-up actions execute the actual tasks after acknowledgment
- Use IGNORE only when you should not respond at all
- If you use IGNORE, do not include any other actions. IGNORE should be used alone when you should not respond or take any actions.

IMPORTANT PROVIDER SELECTION RULES:
- Only include providers if they are needed to respond accurately.
- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see "(Attachments:" in the conversation, you MUST include "ATTACHMENTS" in your providers list
- If the message asks about or references specific people, include "ENTITIES" in your providers list  
- If the message asks about relationships or connections between people, include "RELATIONSHIPS" in your providers list
- If the message asks about facts or specific information, include "FACTS" in your providers list
- If the message asks about the environment or world context, include "WORLD" in your providers list
- If no additional context is needed, you may leave the providers list empty.

IMPORTANT CODE BLOCK FORMATTING RULES:
- If {{agentName}} includes code examples, snippets, or multi-line code in the response, ALWAYS wrap the code with \`\`\` fenced code blocks (specify the language if known, e.g., \`\`\`python).
- ONLY use fenced code blocks for actual code. Do NOT wrap non-code text, instructions, or single words in fenced code blocks.
- If including inline code (short single words or function names), use single backticks (\`) as appropriate.
- This ensures the user sees clearly formatted and copyable code when relevant.

First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
</instructions>

<keys>
"thought" should be a short description of what the agent is thinking about and planning.
"actions" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)
"providers" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use "IGNORE" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)
"text" should be the text of the next message for {{agentName}} which they will send to the conversation.
</keys>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
    <thought>Your thought here</thought>
    <actions>ACTION1,ACTION2</actions>
    <providers>PROVIDER1,PROVIDER2</providers>
    <text>Your response text here</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
```

**Response Format:**
- `<thought>`: Short description of agent's thinking and planning
- `<actions>`: Comma-separated list of actions in execution order
- `<providers>`: Comma-separated list of context providers needed
- `<text>`: The actual response text for the conversation

#### 1.3 postCreationTemplate
Template for creating social media posts in the agent's voice:
```typescript
export const postCreationTemplate = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.

Example task outputs:
1. A post about the importance of AI in our lives
<response>
  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>
  <post>AI is changing the world and it is important to understand how it works</post>
  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>
</response>

2. A post about dogs
<response>
  <thought>I am thinking about writing a post about dogs</thought>
  <post>Dogs are man's best friend and they are loyal and loving</post>
  <imagePrompt>A dog playing with a ball in a park</imagePrompt>
</response>

3. A post about finding a new job
<response>
  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>
  <post>Just keep going!</post>
  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>
</response>

{{providers}}

Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.

Your output should be formatted in XML like this:
<response>
  <thought>Your thought here</thought>
  <post>Your post text here</post>
  <imagePrompt>Optional image prompt here</imagePrompt>
</response>

The "post" field should be the post you want to send. Do not including any thinking or internal reflection in the "post" field.
The "imagePrompt" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.
The "thought" field should be a short description of what the agent is thinking about before responding, including a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
```

**Response Format:**
- `<thought>`: Short description of what the agent is thinking about
- `<post>`: The post text to send
- `<imagePrompt>`: Optional image prompt (single sentence)

#### 1.4 imageDescriptionTemplate
Analyzes and describes images with multiple levels of detail:
```typescript
export const imageDescriptionTemplate = `<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>

<instructions>
Carefully examine the image and provide:
1. A concise, descriptive title that captures the main subject or scene
2. A brief summary description (1-2 sentences) highlighting the key elements
3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details

Be objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.
</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <title>A concise, descriptive title for the image</title>
  <description>A brief 1-2 sentence summary of the key elements in the image</description>
  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
```

**Response Format:**
- `<title>`: Concise, descriptive title for the image
- `<description>`: Brief 1-2 sentence summary of key elements
- `<text>`: Extensive, detailed description covering all visible elements

#### 1.5 replyTemplate
Used specifically for generating character dialog responses in [reply.ts](mdc:packages/plugin-bootstrap/src/actions/reply.ts:25-48):
```typescript
const replyTemplate = `# Task: Generate dialog for the character {{agentName}}.

{{providers}}

# Instructions: Write the next message for {{agentName}}.
"thought" should be a short description of what the agent is thinking about and planning.
"message" should be the next message for {{agentName}} which they will send to the conversation.

IMPORTANT CODE BLOCK FORMATTING RULES:
- If {{agentName}} includes code examples, snippets, or multi-line code in the response, ALWAYS wrap the code with \`\`\` fenced code blocks (specify the language if known, e.g., \`\`\`python).
- ONLY use fenced code blocks for actual code. Do NOT wrap non-code text, instructions, or single words in fenced code blocks.
- If including inline code (short single words or function names), use single backticks (\`) as appropriate.
- This ensures the user sees clearly formatted and copyable code when relevant.

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
    <thought>Your thought here</thought>
    <message>Your message here</message>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
```

**Response Format:**
- `<thought>`: Short description of what the agent is thinking about and planning
- `<message>`: The next message for the agent to send

## 2. Template Processing System

### Core Functions
Templates use Handlebars with a custom processing system in [utils.ts](mdc:packages/core/src/utils.ts:80-91):

#### 2.1 composePrompt
Basic template composition with state values:
```typescript
export const composePrompt = ({
  state,
  template,
}: {
  state: { [key: string]: string };
  template: TemplateType;
}) => {
  const templateStr = typeof template === 'function' ? template({ state }) : template;
  const templateFunction = handlebars.compile(upgradeDoubleToTriple(templateStr));
  const output = composeRandomUser(templateFunction(state), 10);
  return output;
};
```

#### 2.2 composePromptFromState
Advanced template composition with state flattening:
```typescript
export const composePromptFromState = ({
  state,
  template,
}: {
  state: State;
  template: TemplateType;
}) => {
  const templateStr = typeof template === 'function' ? template({ state }) : template;
  const templateFunction = handlebars.compile(upgradeDoubleToTriple(templateStr));

  // get any keys that are in state but are not named text, values or data
  const stateKeys = Object.keys(state);
  const filteredKeys = stateKeys.filter((key) => !['text', 'values', 'data'].includes(key));

  // this flattens out key/values in text/values/data
  const filteredState = filteredKeys.reduce((acc, key) => {
    acc[key] = state[key];
    return acc;
  }, {});

  // and then we flat state.values again
  const output = composeRandomUser(templateFunction({ ...filteredState, ...state.values }), 10);
  return output;
};
```

### Security Features
The system automatically converts double-brace bindings to triple-brace to prevent HTML escaping in [utils.ts](mdc:packages/core/src/utils.ts:25-38):
```typescript
function upgradeDoubleToTriple(tpl) {
  return tpl.replace(
    /(?<!{){{(?![{#\/!>])([\s\S]*?)}}/g,
    (_match, inner) => {
      // keep the block keyword {{else}} unchanged
      if (inner.trim() === 'else') return `{{${inner}}}`;
      return `{{{${inner}}}}`;
    }
  );
}
```

### Random User Generation
Templates support placeholder replacement for example generation in [utils.ts](mdc:packages/core/src/utils.ts:169-179):
```typescript
const composeRandomUser = (template: string, length: number) => {
  const exampleNames = Array.from({ length }, () =>
    uniqueNamesGenerator({ dictionaries: [names] })
  );
  let result = template;
  for (let i = 0; i < exampleNames.length; i++) {
    result = result.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);
  }
  return result;
};
```

## 3. Provider System

### Provider Export
All providers are exported from the bootstrap plugin in [index.ts](mdc:packages/plugin-bootstrap/src/providers/index.ts:1-17):
```typescript
export { actionsProvider } from './actions';
export { actionStateProvider } from './actionState';
export { anxietyProvider } from './anxiety';
export { attachmentsProvider } from './attachments';
export { capabilitiesProvider } from './capabilities';
export { characterProvider } from './character';
export { choiceProvider } from './choice';
export { entitiesProvider } from './entities';
export { evaluatorsProvider } from './evaluators';
export { factsProvider } from './facts';
export { providersProvider } from './providers';
export { recentMessagesProvider } from './recentMessages';
export { relationshipsProvider } from './relationships';
export { roleProvider } from './roles';
export { settingsProvider } from './settings';
export { timeProvider } from './time';
export { worldProvider } from './world';
```

### Key Providers

#### 3.1 Character Provider (CHARACTER)
Supplies character information in [character.ts](mdc:packages/plugin-bootstrap/src/providers/character.ts:18-207):
```typescript
export const characterProvider: Provider = {
  name: 'CHARACTER',
  description: 'Character information',
  get: async (runtime: IAgentRuntime, message: Memory, state: State) => {
    const character = runtime.character;

    // Character name
    const agentName = character.name;

    // Handle bio (string or random selection from array)
    const bioText = Array.isArray(character.bio)
      ? character.bio
          .sort(() => 0.5 - Math.random())
          .slice(0, 10)
          .join(' ')
      : character.bio || '';

    const bio = addHeader(`# About ${character.name}`, bioText);

    // System prompt
    const system = character.system ?? '';

    // Select random topic if available
    const topicString =
      character.topics && character.topics.length > 0
        ? character.topics[Math.floor(Math.random() * character.topics.length)]
        : null;

    const topic = topicString || '';

    // Format topics list
    const topics =
      character.topics && character.topics.length > 0
        ? `${character.name} is also interested in ${character.topics
            .filter((topic) => topic !== topicString)
            .sort(() => 0.5 - Math.random())
            .slice(0, 5)
            .map((topic, index, array) => {
              if (index === array.length - 2) {
                return `${topic} and `;
              }
              if (index === array.length - 1) {
                return topic;
              }
              return `${topic}, `;
            })
            .join('')}`
        : '';

    // Select random adjective if available
    const adjectiveString =
      character.adjectives && character.adjectives.length > 0
        ? character.adjectives[Math.floor(Math.random() * character.adjectives.length)]
        : '';

    const adjective = adjectiveString || '';

    // Format post examples
    const formattedCharacterPostExamples = !character.postExamples
      ? ''
      : character.postExamples
          .sort(() => 0.5 - Math.random())
          .map((post) => {
            const messageString = `${post}`;
            return messageString;
          })
          .slice(0, 50)
          .join('\n');

    const characterPostExamples =
      formattedCharacterPostExamples &&
      formattedCharacterPostExamples.replaceAll('\n', '').length > 0
        ? addHeader(`# Example Posts for ${character.name}`, formattedCharacterPostExamples)
        : '';

    // Format message examples
    const formattedCharacterMessageExamples = !character.messageExamples
      ? ''
      : character.messageExamples
          .sort(() => 0.5 - Math.random())
          .slice(0, 5)
          .map((example) => {
            const exampleNames = Array.from({ length: 5 }, () =>
              Math.random().toString(36).substring(2, 8)
            );

            return example
              .map((message) => {
                let messageString = `${message.name}: ${message.content.text}${
                  message.content.action || message.content.actions
                    ? ` (actions: ${message.content.action || message.content.actions?.join(', ')})`
                    : ''
                }`;
                exampleNames.forEach((name, index) => {
                  const placeholder = `{{name${index + 1}}}`;
                  messageString = messageString.replaceAll(placeholder, name);
                });
                return messageString;
              })
              .join('\n');
          })
          .join('\n\n');

    const characterMessageExamples =
      formattedCharacterMessageExamples &&
      formattedCharacterMessageExamples.replaceAll('\n', '').length > 0
        ? addHeader(
            `# Example Conversations for ${character.name}`,
            formattedCharacterMessageExamples
          )
        : '';

    const room = state.data.room ?? (await runtime.getRoom(message.roomId));

    const isPostFormat = room?.type === ChannelType.FEED || room?.type === ChannelType.THREAD;

    // Style directions
    const postDirections =
      (character?.style?.all?.length && character?.style?.all?.length > 0) ||
      (character?.style?.post?.length && character?.style?.post?.length > 0)
        ? addHeader(
            `# Post Directions for ${character.name}`,
            (() => {
              const all = character?.style?.all || [];
              const post = character?.style?.post || [];
              return [...all, ...post].join('\n');
            })()
          )
        : '';

    const messageDirections =
      (character?.style?.all?.length && character?.style?.all?.length > 0) ||
      (character?.style?.chat?.length && character?.style?.chat?.length > 0)
        ? addHeader(
            `# Message Directions for ${character.name}`,
            (() => {
              const all = character?.style?.all || [];
              const chat = character?.style?.chat || [];
              return [...all, ...chat].join('\n');
            })()
          )
        : '';

    const directions = isPostFormat ? postDirections : messageDirections;
    const examples = isPostFormat ? characterPostExamples : characterMessageExamples;

    const values = {
      agentName,
      bio,
      system,
      topic,
      topics,
      adjective,
      messageDirections,
      postDirections,
      directions,
      examples,
      characterPostExamples,
      characterMessageExamples,
    };

    const data = {
      bio,
      adjective,
      topic,
      topics,
      character,
      directions,
      examples,
      system,
    };

    const topicSentence = topicString
      ? `${character.name} is currently interested in ${topicString}`
      : '';
    const adjectiveSentence = adjectiveString ? `${character.name} is ${adjectiveString}` : '';
    // Combine all text sections
    const text = [bio, adjectiveSentence, topicSentence, topics, directions, examples, system]
      .filter(Boolean)
      .join('\n\n');

    return {
      values,
      data,
      text,
    };
  },
};
```

**Character Provider Output:**
- `agentName`: Character name
- `bio`: Character background information
- `system`: Core behavior instructions
- `topic`: Randomly selected current interest
- `topics`: List of other interests
- `adjective`: Randomly selected personality trait
- `messageDirections`: Behavioral guidelines for chat
- `postDirections`: Behavioral guidelines for posts
- `examples`: Message or post examples based on room type

#### 3.2 Facts Provider (FACTS)
Retrieves relevant facts from memory using semantic search in [facts.ts](mdc:packages/plugin-bootstrap/src/providers/facts.ts:30-118):
```typescript
const factsProvider: Provider = {
  name: 'FACTS',
  description: 'Key facts that the agent knows',
  dynamic: true,
  get: async (runtime: IAgentRuntime, message: Memory, _state?: State) => {
    try {
      // Parallelize initial data fetching operations including recentInteractions
      const recentMessages = await runtime.getMemories({
        tableName: 'messages',
        roomId: message.roomId,
        count: 10,
        unique: false,
      });

      // join the text of the last 5 messages
      const last5Messages = recentMessages
        .slice(-5)
        .map((message) => message.content.text)
        .join('\n');

      const embedding = await runtime.useModel(ModelType.TEXT_EMBEDDING, {
        text: last5Messages,
      });

      const [relevantFacts, recentFactsData] = await Promise.all([
        runtime.searchMemories({
          tableName: 'facts',
          embedding,
          roomId: message.roomId,
          worldId: message.worldId,
          count: 6,
          query: message.content.text,
        }),
        runtime.searchMemories({
          embedding,
          query: message.content.text,
          tableName: 'facts',
          roomId: message.roomId,
          entityId: message.entityId,
          count: 6,
        }),
      ]);

      // join the two and deduplicate
      const allFacts = [...relevantFacts, ...recentFactsData].filter(
        (fact, index, self) => index === self.findIndex((t) => t.id === fact.id)
      );

      if (allFacts.length === 0) {
        return {
          values: {
            facts: '',
          },
          data: {
            facts: allFacts,
          },
          text: 'No facts available.',
        };
      }

      const formattedFacts = formatFacts(allFacts);

      const text = 'Key facts that {{agentName}} knows:\n{{formattedFacts}}'
        .replace('{{agentName}}', runtime.character.name)
        .replace('{{formattedFacts}}', formattedFacts);

      return {
        values: {
          facts: formattedFacts,
        },
        data: {
          facts: allFacts,
        },
        text,
      };
    } catch (error) {
      logger.error({ error }, 'Error in factsProvider:');
      return {
        values: {
          facts: '',
        },
        data: {
          facts: [],
        },
        text: 'Error retrieving facts.',
      };
    }
  },
};
```

**Facts Provider Output:**
- `facts`: Formatted facts text
- `data.facts`: Array of fact memories
- `text`: Complete facts text with agent name

#### 3.3 Entities Provider (ENTITIES)
Provides information about people in the current conversation in [entities.ts](mdc:packages/plugin-bootstrap/src/providers/entities.ts:8-40):
```typescript
export const entitiesProvider: Provider = {
  name: 'ENTITIES',
  description: 'People in the current conversation',
  dynamic: true,
  get: async (runtime: IAgentRuntime, message: Memory) => {
    const { roomId, entityId } = message;
    // Get entities details
    const entitiesData = await getEntityDetails({ runtime, roomId });
    // Format entities for display
    const formattedEntities = formatEntities({ entities: entitiesData ?? [] });
    // Find sender name
    const senderName = entitiesData?.find((entity: Entity) => entity.id === entityId)?.names[0];
    // Create formatted text with header
    const entities =
      formattedEntities && formattedEntities.length > 0
        ? addHeader('# People in the Room', formattedEntities)
        : '';
    const data = {
      entitiesData,
      senderName,
    };

    const values = {
      entities,
    };

    return {
      data,
      values,
      text: entities,
    };
  },
};
```

**Entities Provider Output:**
- `entities`: Formatted entities text with header
- `data.entitiesData`: Array of entity data
- `data.senderName`: Name of the message sender
- `text`: Complete entities text

## 4. Character Definition System

### Character Structure
Character definitions are the foundation that feeds into templates. Example structure shown in the TEE starter project in [character.ts](mdc:packages/project-tee-starter/src/character.ts:19-271):

```typescript
export const mrTeeCharacter: Character = {
  name: 'Mr. TEE',
  plugins: [
    // Core plugins first
    '@elizaos/plugin-sql',
    '@elizaos/plugin-bootstrap',
    // ... other plugins
  ],
  settings: {
    secrets: {
      DISCORD_APPLICATION_ID: process.env.MR_TEE_DISCORD_APPLICATION_ID,
      DISCORD_API_TOKEN: process.env.MR_TEE_DISCORD_API_TOKEN,
      // ... other secrets
    },
    avatar,
  },
  system: `You are Mr. TEE—the Trusted Execution Environment drill sergeant. Your mission: forge secure, paranoid developers who understand TEE technology while keeping Mr. T's trademark grit.
  
  Tone & Style:
  • Speak with high-energy authority. Use signature lines like 'I pity the fool who skips attestation!' sparingly but memorably.
  • Keep responses tight, actionable, and laced with tough love about security.
  • No nonsense, no shortcuts, no excuses when it comes to security.
  
  Content Guidance:
  • Explain TEE concepts clearly: remote attestation, secure enclaves, key derivation, trusted computing
  • Drill security best practices first—never expose keys, always verify attestation, validate trust chains
  • Highlight TEE benefits: hardware-based security, isolated execution, encrypted memory
  • Translate complex security concepts into plain language with military metaphors
  • Emphasize the importance of threat modeling and security audits
  
  Behavioral Reminders:
  • Motivate through tough love; security laziness gets no sympathy
  • Always remind: 'Trust but verify—especially in TEE!'
  • Encourage paranoid thinking—it's not paranoia if they're really after your keys
  • Every reply should inspire better security practices and respect for TEE technology`,
  
  bio: [
    'TEE Security Enforcer',
    'Enclave Drill Sergeant',
    'Attestation Authority',
    "Forged in the fires of hardware security modules and battle-tested through countless security audits, Mr. TEE transformed Mr. T's street toughness into cryptographic strength.",
    // ... more bio entries
  ],
  
  messageExamples: [
    [
      { name: '{{user}}', content: { text: 'What is a TEE?' } },
      {
        name: 'Mr. TEE',
        content: {
          text: "Listen up, recruit! A Trusted Execution Environment is like a military bunker for your code—isolated, fortified, and tamper-proof. It runs your sensitive operations in hardware-protected memory where even the OS can't peek. I pity the fool who runs crypto keys in regular memory!",
        },
      },
    ],
    // ... more message examples
  ],
  
  postExamples: [
    "Remote attestation ain't optional—it's your proof of security! Skip it and I pity your unverified enclave! #TEESecurity",
    'Keys generated outside TEE are like passwords on sticky notes—WEAK! Hardware root of trust or bust! #CryptoStrength',
    // ... more post examples
  ],
  
  style: {
    all: [
      'Direct and commanding',
      'Security-focused with no compromise',
      'Military metaphors and analogies',
      'Technical accuracy wrapped in tough talk',
      'No sugarcoating security risks',
      'Action-oriented responses',
      'Emphasize verification over trust',
      'Quick to call out bad security practices',
    ],
    chat: [
      'Respond to all security questions with authority',
      'Challenge weak security assumptions',
      'Provide actionable security advice',
      "Use 'I pity the fool' sparingly but effectively",
      'Always verify before trusting',
    ],
    post: [
      'Bold security statements',
      'Concise security wisdom',
      'Memorable security rules',
      'TEE evangelism with attitude',
    ],
  },
};
```

**Key Character Properties:**
- `name`: Agent identity
- `system`: Core behavior instructions
- `bio`: Background information array
- `messageExamples`: Dialog examples for training
- `postExamples`: Social media examples
- `topics`: Interest areas
- `adjectives`: Personality traits
- `style`: Behavioral guidelines for different contexts

## 5. Agent Templates

### Quick-Start Templates
Quick-start configurations are available for different use cases in [agent-templates.ts](mdc:packages/client/src/config/agent-templates.ts:16-77):

```typescript
export const agentTemplates: AgentTemplate[] = [
  {
    id: 'none',
    label: 'None (Start Blank)',
    description: 'Start with an empty configuration',
    template: {
      name: '',
      username: '',
      system: '',
      bio: [],
      topics: [],
      adjectives: [],
      plugins: ['@elizaos/plugin-sql', '@elizaos/plugin-openai', '@elizaos/plugin-bootstrap'],
      settings: { secrets: {} },
    },
  },
  
  // Client-specific agents
  {
    id: 'discord-bot',
    label: 'Discord Bot',
    description: 'Interactive Discord bot that handles server interactions',
    template: {
      name: 'Discord Assistant',
      username: 'discordbot',
      system: 'You are a Discord bot designed to assist users in a Discord server. You respond to messages, handle commands, and provide helpful information to community members. You should be friendly, helpful, and maintain a consistent personality. Focus on providing value to the community through clear, concise responses.',
      bio: [
        'Helpful Discord community assistant',
        'Responds to commands and natural language queries',
        'Assists with server-specific information and resources',
        'Maintains a friendly and helpful tone',
      ],
      topics: ['Discord server', 'Community assistance', 'Command handling', 'Server information'],
      adjectives: ['Helpful', 'Responsive', 'Friendly', 'Informative', 'Reliable'],
      plugins: [
        '@elizaos/plugin-sql',
        '@elizaos/plugin-openai',
        '@elizaos/plugin-bootstrap',
        '@elizaos/plugin-discord',
      ],
      style: {
        all: [
          'Be friendly and helpful',
          'Use clear, concise language',
          'Follow Discord conventions',
        ],
        chat: [
          'Respond promptly to queries',
          'Use appropriate formatting for clarity',
          'Reference relevant commands when helpful',
        ],
        post: [
          'Structure longer responses with clear sections',
          'Use embeds for rich content when appropriate',
        ],
      },
      settings: {
        secrets: {},
      },
    },
  },
  // ... more templates
];
```

## 6. Message Processing Pipeline

### Bootstrap Plugin Integration
Templates are used in the main message processing pipeline in the bootstrap plugin in [index.ts](mdc:packages/plugin-bootstrap/src/plugins/index.ts:1-48):

```typescript
import {
  shouldRespondTemplate,
  messageHandlerTemplate,
  postCreationTemplate,
  imageDescriptionTemplate,
  // ... other imports
} from '@elizaos/core';

// Template usage in message handlers
const prompt = composePromptFromState({
  state,
  template: shouldRespondTemplate,
});

// Template usage in reply actions
const prompt = composePromptFromState({
  state,
  template: runtime.character.templates?.replyTemplate || replyTemplate,
});
```

### Template State Composition
The system flattens state data when processing templates, excluding 'text', 'values', and 'data' keys from the main state and merging in state.values in [utils.ts](mdc:packages/core/src/utils.ts:112-124):

```typescript
// get any keys that are in state but are not named text, values or data
const stateKeys = Object.keys(state);
const filteredKeys = stateKeys.filter((key) => !['text', 'values', 'data'].includes(key));

// this flattens out key/values in text/values/data
const filteredState = filteredKeys.reduce((acc, key) => {
  acc[key] = state[key];
  return acc;
}, {});

// and then we flat state.values again
const output = composeRandomUser(templateFunction({ ...filteredState, ...state.values }), 10);
```

## 7. How to Use Templates to Your Advantage

### 1. Leverage Provider Selection
Templates automatically include relevant providers based on message content. The messageHandlerTemplate has specific rules for when to include each provider:

- **ATTACHMENTS**: When message mentions images, photos, pictures, attachments, or visual content
- **ENTITIES**: When message asks about or references specific people
- **RELATIONSHIPS**: When message asks about relationships or connections between people
- **FACTS**: When message asks about facts or specific information
- **WORLD**: When message asks about environment or world context

### 2. Customize Response Patterns
Use the action ordering system in messageHandlerTemplate to control response flow:

- **REPLY actions acknowledge first**, then execute tasks
- **Common patterns**:
  - For requests requiring tool use: `REPLY,CALL_MCP_TOOL`
  - For task execution: `REPLY,SEND_MESSAGE` or `REPLY,EVM_SWAP_TOKENS`
  - For multi-step operations: `REPLY,ACTION1,ACTION2`

### 3. Character Behavior Control
The character provider randomly selects from bio arrays, topics, and adjectives, providing natural variation:

- **Bio arrays**: Multiple background descriptions for variety
- **Topics**: Current interests that change randomly
- **Adjectives**: Personality traits that vary per interaction
- **Style guides**: Context-specific behavioral guidelines

## 8. How to Customize Templates

### 1. Modify Core Templates
Edit templates directly in the prompts file for system-wide changes in [prompts.ts](mdc:packages/core/src/prompts.ts:1-163).

### 2. Create Custom Character Definitions
Define new characters with custom bio, examples, and style guides following the structure in [character.ts](mdc:packages/project-tee-starter/src/character.ts:19-271).

### 3. Use Agent Templates
Quick-start templates are available for different use cases like Discord bots in [agent-templates.ts](mdc:packages/client/src/config/agent-templates.ts:16-77).

## 9. How to Extend Templates

### 1. Create Custom Providers
Build new providers following the standard interface to supply additional context data to templates:

```typescript
const customProvider: Provider = {
  name: 'CUSTOM_DATA',
  description: 'Custom data for templates',
  dynamic: true,
  get: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
    // Your custom logic here
    return {
      values: { customData: 'value' },
      data: { customData: 'value' },
      text: 'Custom data: value'
    };
  }
};
```

### 2. Add New Templates
Create additional template types for specialized use cases by following the existing pattern:

```typescript
export const customTemplate = `<task>Your custom task description.</task>

<providers>
{{providers}}
</providers>

<instructions>Your custom instructions here.</instructions>

<output>
Your custom output format here.
</output>`;
```

### 3. Plugin System Integration
Templates work with the plugin system where providers and actions can be added through plugins in [index.ts](mdc:packages/plugin-bootstrap/src/index.ts:38-47).

## 10. Critical Development Rules

### XML Response Format Requirements
- **ALL LLM responses must be contained within `<response></response>` XML blocks**
- **No text, thinking, or reasoning should appear before or after the XML block**
- **Responses must start immediately with `<response>` and end with `</response>`**

### Action Ordering Rules
- **Actions execute in the ORDER listed - sequence matters**
- **REPLY should come FIRST to acknowledge user requests**
- **Use IGNORE only when no response is needed (and use it alone)**

### Provider Selection Rules
- **Only include providers if needed for accurate responses**
- **Must include "ATTACHMENTS" if message mentions visual content**
- **Include "ENTITIES" for questions about specific people**
- **Include "RELATIONSHIPS" for questions about connections**
- **Include "FACTS" for factual information requests**
- **Include "WORLD" for environment context questions**
- **Never use "IGNORE" as a provider name**

### Code Block Formatting Rules
- **Always wrap code examples with ``` fenced code blocks**
- **Specify language if known (e.g., ```python)**
- **Only use fenced blocks for actual code**
- **Use single backticks (`) for inline code elements**
- **Never wrap non-code text in code blocks**

### Template Compilation Process
- **Double-brace placeholders ({{placeholder}}) are converted to triple-brace for non-HTML escaping**
- **State values populate template placeholders**
- **Random user name generation for placeholder values**

## 11. Best Practices

### 1. Template Structure
- Always include `<task>`, `<providers>`, `<instructions>`, and `<output>` sections
- Use clear, descriptive task descriptions
- Provide specific formatting requirements in output section

### 2. Provider Usage
- Only include providers that are actually needed
- Follow the provider selection rules strictly
- Test provider integration thoroughly

### 3. Character Development
- Create diverse bio arrays for natural variation
- Use topics and adjectives to add personality depth
- Provide comprehensive style guides for different contexts
- Include realistic message and post examples

### 4. Template Testing
- Test templates with various input scenarios
- Verify XML parsing works correctly
- Ensure provider data is properly formatted
- Test action ordering and execution

### 5. Performance Considerations
- Keep templates concise but comprehensive
- Avoid unnecessary provider calls
- Use efficient state composition
- Cache frequently used template data

This comprehensive guide covers all aspects of the ElizaOS Template System, from basic usage to advanced customization. Follow these patterns and best practices to build robust, engaging agent systems.
